name: Mstdn and Bsky to Obsidian Sync

on:
  schedule:
    # æ¯æ—¥3:00 JST (18:00 UTC)ã«å®Ÿè¡Œ
    - cron: '0 18 * * *'
  workflow_dispatch:
    inputs:
      force_full_sync:
        description: 'Force full sync (all data)'
        required: false
        default: 'false'
        type: choice
        options:
        - 'false'
        - 'true'

permissions:
  contents: write
  actions: read

jobs:
  sync-all-social-media:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        pip install requests python-dateutil
        
    - name: Create Thino directory
      run: |
        mkdir -p Thino
        
    - name: Run unified sync
      env:
        # Mastodonè¨­å®š
        MASTODON_ACCESS_TOKEN: ${{ secrets.MASTODON_ACCESS_TOKEN }}
        MASTODON_INSTANCE_URL: ${{ secrets.MASTODON_INSTANCE_URL }}
        # Blueskyè¨­å®š
        BLUESKY_HANDLE: ${{ secrets.BLUESKY_HANDLE }}
        BLUESKY_PASSWORD: ${{ secrets.BLUESKY_PASSWORD }}
        # å…±é€šè¨­å®š
        GITHUB_REPOSITORY: ${{ github.repository }}
        FORCE_FULL_SYNC: ${{ github.event.inputs.force_full_sync || 'false' }}
        GITHUB_EVENT_NAME: ${{ github.event_name }}
      run: |
        python3 << 'EOF'
        import requests
        import json
        import os
        import re
        import time
        import logging
        from datetime import datetime, timedelta, timezone
        from html import unescape
        from dateutil import parser
        
        # ãƒ­ã‚®ãƒ³ã‚°è¨­å®š
        logging.basicConfig(
            level=logging.INFO, 
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        
        # æ—¥æœ¬æ™‚é–“ã®ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³
        JST = timezone(timedelta(hours=9))
        
        # ç’°å¢ƒå¤‰æ•°ã®èª­ã¿è¾¼ã¿
        MASTODON_ACCESS_TOKEN = os.getenv('MASTODON_ACCESS_TOKEN')
        MASTODON_INSTANCE_URL = os.getenv('MASTODON_INSTANCE_URL')
        BLUESKY_HANDLE = os.getenv('BLUESKY_HANDLE')
        BLUESKY_PASSWORD = os.getenv('BLUESKY_PASSWORD')
        GITHUB_REPOSITORY = os.getenv('GITHUB_REPOSITORY')
        FORCE_FULL_SYNC = os.getenv('FORCE_FULL_SYNC') == 'true'
        GITHUB_EVENT_NAME = os.getenv('GITHUB_EVENT_NAME')
        
        # çµ±ä¸€çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«
        UNIFIED_STATE_FILE = 'Thino/.unified-sync-state.json'
        
        
        class UnifiedSyncState:
            """çµ±ä¸€ã•ã‚ŒãŸåŒæœŸçŠ¶æ…‹ç®¡ç†"""
            def __init__(self):
                self.state = self.load()
                
            def load(self):
                """çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€"""
                if os.path.exists(UNIFIED_STATE_FILE):
                    try:
                        with open(UNIFIED_STATE_FILE, 'r') as f:
                            return json.load(f)
                    except:
                        pass
                
                # åˆæœŸçŠ¶æ…‹
                return {
                    'mastodon': {
                        'last_post_id': None,
                        'last_execution_time': None
                    },
                    'bluesky': {
                        'last_execution_time': None
                    },
                    'is_first_run': True
                }
            
            def save(self):
                """çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜"""
                self.state['last_updated'] = datetime.now(JST).isoformat()
                os.makedirs(os.path.dirname(UNIFIED_STATE_FILE), exist_ok=True)
                with open(UNIFIED_STATE_FILE, 'w') as f:
                    json.dump(self.state, f, indent=2, ensure_ascii=False)
                logging.info(f"çµ±ä¸€çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜: {UNIFIED_STATE_FILE}")
        
        
        class MastodonSync:
            """MastodonåŒæœŸå‡¦ç†"""
            def __init__(self, instance_url, access_token, state):
                self.instance_url = instance_url.rstrip('/')
                self.headers = {
                    'Authorization': f'Bearer {access_token}',
                    'Content-Type': 'application/json'
                }
                self.state = state
                # æ™‚åˆ»ãƒ•ã‚£ãƒ«ã‚¿è¨­å®š
                is_manual = GITHUB_EVENT_NAME == 'workflow_dispatch'
                self.hours_to_fetch = 48 if is_manual else 25
                self.cutoff_time = datetime.now(timezone.utc) - timedelta(hours=self.hours_to_fetch)
                
            def get_account_id(self):
                """ã‚¢ã‚«ã‚¦ãƒ³ãƒˆIDã‚’å–å¾—"""
                try:
                    response = requests.get(
                        f"{self.instance_url}/api/v1/accounts/verify_credentials",
                        headers=self.headers,
                        timeout=30
                    )
                    response.raise_for_status()
                    return response.json()['id']
                except Exception as e:
                    logging.error(f"Mastodonã‚¢ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
                    return None
                    
            def fetch_posts(self, account_id):
                """è‡ªåˆ†ã®æŠ•ç¨¿ã‚’å–å¾—ï¼ˆå·®åˆ†å¯¾å¿œï¼‰"""
                logging.info("MastodonæŠ•ç¨¿ã‚’å–å¾—ä¸­...")
                posts = []
                
                try:
                    if self.state.state['is_first_run'] or FORCE_FULL_SYNC:
                        # å…¨ä»¶å–å¾—
                        logging.info("  åˆå›å®Ÿè¡Œã¾ãŸã¯å¼·åˆ¶ãƒ•ãƒ«åŒæœŸ - å…¨ä»¶å–å¾—")
                        max_id = None
                        while True:
                            params = {'limit': 40}
                            if max_id:
                                params['max_id'] = max_id
                            
                            response = requests.get(
                                f"{self.instance_url}/api/v1/accounts/{account_id}/statuses",
                                headers=self.headers,
                                params=params,
                                timeout=30
                            )
                            response.raise_for_status()
                            data = response.json()
                            
                            if not data:
                                break
                                
                            posts.extend(data)
                            max_id = data[-1]['id']
                            time.sleep(1)  # ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–
                    else:
                        # å·®åˆ†å–å¾—
                        last_id = self.state.state['mastodon'].get('last_post_id')
                        if last_id:
                            logging.info(f"  å·®åˆ†å–å¾— - since_id: {last_id}")
                            params = {'limit': 40, 'since_id': last_id}
                            response = requests.get(
                                f"{self.instance_url}/api/v1/accounts/{account_id}/statuses",
                                headers=self.headers,
                                params=params,
                                timeout=30
                            )
                            response.raise_for_status()
                            posts = response.json()
                    
                    logging.info(f"âœ… MastodonæŠ•ç¨¿å–å¾—å®Œäº†: {len(posts)}ä»¶")
                    return posts
                    
                except Exception as e:
                    logging.error(f"MastodonæŠ•ç¨¿å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
                    return []
                    
            def fetch_favourites(self):
                """ãŠæ°—ã«å…¥ã‚Šã‚’å–å¾—ï¼ˆæ™‚åˆ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼‰"""
                logging.info(f"MastodonãŠæ°—ã«å…¥ã‚Šå–å¾—é–‹å§‹ï¼ˆ{self.hours_to_fetch}æ™‚é–“ä»¥å†…ï¼‰")
                
                try:
                    response = requests.get(
                        f"{self.instance_url}/api/v1/favourites",
                        headers=self.headers,
                        params={'limit': 40},
                        timeout=30
                    )
                    response.raise_for_status()
                    data = response.json()
                    
                    if not data:
                        logging.info("ãŠæ°—ã«å…¥ã‚ŠãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
                        return []
                    
                    # æ™‚åˆ»ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                    recent_items = []
                    for item in data:
                        created_at = datetime.fromisoformat(
                            item['created_at'].replace('Z', '+00:00')
                        )
                        if created_at > self.cutoff_time:
                            recent_items.append(item)
                    
                    logging.info(f"âœ… ãŠæ°—ã«å…¥ã‚Šå–å¾—å®Œäº†: {len(recent_items)}/{len(data)}ä»¶ãŒå¯¾è±¡")
                    return recent_items
                    
                except Exception as e:
                    logging.error(f"MastodonãŠæ°—ã«å…¥ã‚Šå–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
                    return []
                    
            def fetch_bookmarks(self):
                """ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã‚’å–å¾—ï¼ˆæ™‚åˆ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼‰"""
                logging.info(f"Mastodonãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯å–å¾—é–‹å§‹ï¼ˆ{self.hours_to_fetch}æ™‚é–“ä»¥å†…ï¼‰")
                
                try:
                    response = requests.get(
                        f"{self.instance_url}/api/v1/bookmarks",
                        headers=self.headers,
                        params={'limit': 40},
                        timeout=30
                    )
                    response.raise_for_status()
                    data = response.json()
                    
                    if not data:
                        logging.info("ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
                        return []
                    
                    # æ™‚åˆ»ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                    recent_items = []
                    for item in data:
                        created_at = datetime.fromisoformat(
                            item['created_at'].replace('Z', '+00:00')
                        )
                        if created_at > self.cutoff_time:
                            recent_items.append(item)
                    
                    logging.info(f"âœ… ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯å–å¾—å®Œäº†: {len(recent_items)}/{len(data)}ä»¶ãŒå¯¾è±¡")
                    return recent_items
                    
                except Exception as e:
                    logging.error(f"Mastodonãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
                    return []
                    
            def clean_html(self, html_content):
                """HTMLã‚¿ã‚°ã‚’é™¤å»"""
                if not html_content:
                    return ""
                
                text = unescape(html_content)
                
                # Mastodonãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã®å‡¦ç†
                text = re.sub(r'<a[^>]*class="[^"]*hashtag[^"]*"[^>]*>#<span>([^<]*)</span></a>', r'#\1', text)
                # é€šå¸¸ã®ãƒªãƒ³ã‚¯
                text = re.sub(r'<a href="([^"]*)"[^>]*>([^<]*)</a>', r'[\2](\1)', text)
                # HTMLã‚¿ã‚°ã‚’é™¤å»
                text = re.sub(r'<p>', '', text)
                text = re.sub(r'</p>', ' ', text)
                text = re.sub(r'<br\s*/?>', ' ', text)
                text = re.sub(r'<[^>]+>', '', text)
                # ä½™åˆ†ãªã‚¹ãƒšãƒ¼ã‚¹ã‚’æ•´ç†
                text = re.sub(r'\s+', ' ', text)
                
                return text.strip()
                
            def format_entry(self, item, entry_type):
                """ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’Thinoå½¢å¼ã«å¤‰æ›"""
                post_time_utc = datetime.fromisoformat(
                    item['created_at'].replace('Z', '+00:00')
                )
                post_time_jst = post_time_utc.astimezone(JST)
                time_str = post_time_jst.strftime('%H:%M')
                
                if entry_type == 'post':
                    content = self.clean_html(item['content'])
                    return {
                        'entry': f"- {time_str} {content} #via_mastodon",
                        'date': post_time_jst.date(),
                        'time': post_time_jst
                    }
                elif entry_type == 'favourite':
                    content = self.clean_html(item['content'])
                    account = item['account']
                    author_name = account['display_name'] or account['username']
                    return {
                        'entry': f"- {time_str} â­ï¸{author_name} {content} #via_mastodon_fav",
                        'date': post_time_jst.date(),
                        'time': post_time_jst
                    }
                elif entry_type == 'bookmark':
                    content = self.clean_html(item['content'])
                    account = item['account']
                    author_name = account['display_name'] or account['username']
                    return {
                        'entry': f"- {time_str} ğŸ”–{author_name} {content} #via_mastodon_bookmark",
                        'date': post_time_jst.date(),
                        'time': post_time_jst
                    }
        
        
        class BlueskySync:
            """BlueskyåŒæœŸå‡¦ç†ï¼ˆrequestsä½¿ç”¨ï¼‰"""
            def __init__(self, handle, password, state):
                self.handle = handle
                self.password = password
                self.state = state
                self.session = None
                self.did = None
                self.base_url = 'https://bsky.social'
                
            def login(self):
                """Blueskyã«ãƒ­ã‚°ã‚¤ãƒ³"""
                try:
                    # ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ
                    login_data = {
                        'identifier': self.handle,
                        'password': self.password
                    }
                    
                    response = requests.post(
                        f'{self.base_url}/xrpc/com.atproto.server.createSession',
                        json=login_data,
                        headers={'Content-Type': 'application/json'}
                    )
                    
                    if response.status_code == 200:
                        data = response.json()
                        self.session = data.get('accessJwt')
                        self.did = data.get('did')
                        logging.info("âœ… Blueskyãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ")
                        logging.info(f"  DID: {self.did}")
                        return True
                    else:
                        logging.error(f"Blueskyãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—: {response.status_code}")
                        logging.error(f"ãƒ¬ã‚¹ãƒãƒ³ã‚¹: {response.text}")
                        return False
                        
                except Exception as e:
                    logging.error(f"Blueskyãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
                    return False
                    
            def api_request(self, endpoint, params=None):
                """Bluesky APIãƒªã‚¯ã‚¨ã‚¹ãƒˆ"""
                if not self.session:
                    logging.error("ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒç„¡åŠ¹ã§ã™")
                    return None
                    
                headers = {
                    'Authorization': f'Bearer {self.session}',
                    'Content-Type': 'application/json'
                }
                
                try:
                    response = requests.get(
                        f'{self.base_url}/xrpc/{endpoint}',
                        params=params,
                        headers=headers
                    )
                    
                    if response.status_code == 200:
                        return response.json()
                    else:
                        logging.error(f"APIã‚¨ãƒ©ãƒ¼ {endpoint}: {response.status_code}")
                        return None
                        
                except Exception as e:
                    logging.error(f"APIãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
                    return None
                    
            def fetch_activities(self):
                """æŠ•ç¨¿ãƒ»ãƒªãƒã‚¹ãƒˆãƒ»ãƒªãƒ—ãƒ©ã‚¤ã‚’å–å¾—"""
                if not self.session:
                    return []
                    
                logging.info("Blueskyã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’å–å¾—ä¸­...")
                activities = []
                
                try:
                    # å·®åˆ†å–å¾—ã®åŸºæº–æ™‚åˆ»
                    if self.state.state['is_first_run'] or FORCE_FULL_SYNC:
                        cutoff_time = datetime(1970, 1, 1, tzinfo=timezone.utc)
                        logging.info("  åˆå›å®Ÿè¡Œã¾ãŸã¯å¼·åˆ¶ãƒ•ãƒ«åŒæœŸ - å…¨ä»¶å–å¾—")
                    else:
                        last_time = self.state.state['bluesky'].get('last_execution_time')
                        if last_time:
                            cutoff_time = datetime.fromisoformat(last_time)
                            logging.info(f"  å·®åˆ†å–å¾— - å‰å›å®Ÿè¡Œæ™‚åˆ»: {last_time}")
                        else:
                            cutoff_time = datetime(1970, 1, 1, tzinfo=timezone.utc)
                    
                    # ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’å–å¾—
                    cursor = None
                    page_count = 0
                    
                    while True:
                        page_count += 1
                        logging.info(f"  ãƒšãƒ¼ã‚¸ {page_count} å–å¾—ä¸­...")
                        
                        # APIãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                        params = {'actor': self.did, 'limit': 50}
                        if cursor:
                            params['cursor'] = cursor
                        
                        # ãƒ•ã‚£ãƒ¼ãƒ‰å–å¾—
                        data = self.api_request('app.bsky.feed.getAuthorFeed', params)
                        
                        if not data or 'feed' not in data or not data['feed']:
                            logging.info(f"  ãƒšãƒ¼ã‚¸ {page_count}: ãƒ‡ãƒ¼ã‚¿ãªã—")
                            break
                        
                        # è‡ªåˆ†ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿
                        for item in data['feed']:
                            # ãƒªãƒã‚¹ãƒˆã®å ´åˆ
                            if 'reason' in item and item['reason']:
                                if item['reason'].get('$type') == 'app.bsky.feed.defs#reasonRepost':
                                    if item['reason']['by']['did'] == self.did:
                                        try:
                                            activity_time = parser.parse(item['reason']['indexedAt']).replace(tzinfo=timezone.utc)
                                            if activity_time > cutoff_time:
                                                activities.append(item)
                                        except Exception as e:
                                            logging.warning(f"ãƒªãƒã‚¹ãƒˆæ™‚åˆ»è§£æã‚¨ãƒ©ãƒ¼: {e}")
                            
                            # æŠ•ç¨¿ãƒ»ãƒªãƒ—ãƒ©ã‚¤ã®å ´åˆ
                            elif 'post' in item and item['post']['author']['did'] == self.did:
                                try:
                                    created_at = item['post']['record'].get('createdAt', item['post'].get('indexedAt'))
                                    if created_at:
                                        activity_time = parser.parse(created_at).replace(tzinfo=timezone.utc)
                                        if activity_time > cutoff_time:
                                            activities.append(item)
                                except Exception as e:
                                    logging.warning(f"æŠ•ç¨¿æ™‚åˆ»è§£æã‚¨ãƒ©ãƒ¼: {e}")
                        
                        # ã‚«ãƒ¼ã‚½ãƒ«æ›´æ–°
                        cursor = data.get('cursor')
                        if not cursor:
                            logging.info(f"  ãƒšãƒ¼ã‚¸ {page_count}: æœ€çµ‚ãƒšãƒ¼ã‚¸")
                            break
                            
                        # ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–
                        time.sleep(0.8)
                    
                    logging.info(f"âœ… Blueskyã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£å–å¾—å®Œäº†: {len(activities)}ä»¶")
                    return activities
                    
                except Exception as e:
                    logging.error(f"Blueskyã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
                    logging.error(f"è©³ç´°: {type(e).__name__}: {str(e)}")
                    return []
                    
            def fetch_likes(self):
                """ãƒ©ã‚¤ã‚¯ã‚’å–å¾—"""
                if not self.session:
                    return []
                    
                logging.info("Blueskyãƒ©ã‚¤ã‚¯ã‚’å–å¾—ä¸­...")
                likes = []
                
                try:
                    # å·®åˆ†å–å¾—ã®åŸºæº–æ™‚åˆ»
                    if self.state.state['is_first_run'] or FORCE_FULL_SYNC:
                        cutoff_time = datetime(1970, 1, 1, tzinfo=timezone.utc)
                        logging.info("  åˆå›å®Ÿè¡Œã¾ãŸã¯å¼·åˆ¶ãƒ•ãƒ«åŒæœŸ - å…¨ä»¶å–å¾—")
                    else:
                        last_time = self.state.state['bluesky'].get('last_execution_time')
                        if last_time:
                            cutoff_time = datetime.fromisoformat(last_time)
                        else:
                            cutoff_time = datetime(1970, 1, 1, tzinfo=timezone.utc)
                    
                    # ãƒ©ã‚¤ã‚¯ã‚’å–å¾—
                    cursor = None
                    page_count = 0
                    
                    while True:
                        page_count += 1
                        logging.info(f"  ãƒšãƒ¼ã‚¸ {page_count} å–å¾—ä¸­...")
                        
                        # APIãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                        params = {'actor': self.did, 'limit': 25}
                        if cursor:
                            params['cursor'] = cursor
                        
                        # ãƒ©ã‚¤ã‚¯å–å¾—
                        data = self.api_request('app.bsky.feed.getActorLikes', params)
                        
                        if not data or 'feed' not in data or not data['feed']:
                            logging.info(f"  ãƒšãƒ¼ã‚¸ {page_count}: ãƒ‡ãƒ¼ã‚¿ãªã—")
                            break
                        
                        # å…ƒæŠ•ç¨¿ã®ä½œæˆæ™‚åˆ»ã§ãƒ•ã‚£ãƒ«ã‚¿
                        for item in data['feed']:
                            try:
                                created_at = item['post']['record'].get('createdAt', item['post'].get('indexedAt'))
                                if created_at:
                                    post_time = parser.parse(created_at).replace(tzinfo=timezone.utc)
                                    if post_time > cutoff_time:
                                        likes.append(item)
                            except Exception as e:
                                logging.warning(f"ãƒ©ã‚¤ã‚¯æ™‚åˆ»è§£æã‚¨ãƒ©ãƒ¼: {e}")
                        
                        # ã‚«ãƒ¼ã‚½ãƒ«æ›´æ–°
                        cursor = data.get('cursor')
                        if not cursor:
                            logging.info(f"  ãƒšãƒ¼ã‚¸ {page_count}: æœ€çµ‚ãƒšãƒ¼ã‚¸")
                            break
                            
                        # ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–
                        time.sleep(1)
                    
                    logging.info(f"âœ… Blueskyãƒ©ã‚¤ã‚¯å–å¾—å®Œäº†: {len(likes)}ä»¶")
                    return likes
                    
                except Exception as e:
                    logging.error(f"Blueskyãƒ©ã‚¤ã‚¯å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
                    return []
                    
            def process_facets(self, text, facets):
                """Blueskyã®ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆã‚’å‡¦ç†"""
                if not text or not facets:
                    return text
                    
                # ãƒã‚¤ãƒˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ–‡å­—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¤‰æ›ã™ã‚‹å‡¦ç†
                # (ç°¡ç•¥åŒ–ã®ãŸã‚ã€ASCIIãƒ†ã‚­ã‚¹ãƒˆã¨ä»®å®š)
                return text
                
            def format_entry(self, item, entry_type):
                """ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’Thinoå½¢å¼ã«å¤‰æ›"""
                if entry_type == 'activity':
                    # ãƒªãƒã‚¹ãƒˆã®å ´åˆ
                    if 'reason' in item and item['reason']:
                        if item['reason'].get('$type') == 'app.bsky.feed.defs#reasonRepost':
                            repost_time = parser.parse(item['reason']['indexedAt']).replace(tzinfo=timezone.utc)
                            time_jst = repost_time.astimezone(JST)
                            time_str = time_jst.strftime('%H:%M')
                            author = item['post']['author'].get('displayName') or item['post']['author']['handle']
                            content = item['post']['record'].get('text', '')
                            return {
                                'entry': f"- {time_str} RP @{author} {content} #via_bluesky",
                                'date': time_jst.date(),
                                'time': time_jst
                            }
                    
                    # é€šå¸¸ã®æŠ•ç¨¿ãƒ»ãƒªãƒ—ãƒ©ã‚¤
                    created_at = item['post']['record'].get('createdAt', item['post'].get('indexedAt'))
                    post_time = parser.parse(created_at).replace(tzinfo=timezone.utc)
                    time_jst = post_time.astimezone(JST)
                    time_str = time_jst.strftime('%H:%M')
                    content = item['post']['record'].get('text', '')
                    
                    if item['post']['record'].get('reply'):
                        return {
                            'entry': f"- {time_str} Re {content} #via_bluesky",
                            'date': time_jst.date(),
                            'time': time_jst
                        }
                    else:
                        return {
                            'entry': f"- {time_str} {content} #via_bluesky",
                            'date': time_jst.date(),
                            'time': time_jst
                        }
                        
                elif entry_type == 'like':
                    # ãƒ©ã‚¤ã‚¯ã¯å…ƒæŠ•ç¨¿ã®ä½œæˆæ™‚åˆ»ã‚’ä½¿ç”¨
                    created_at = item['post']['record'].get('createdAt', item['post'].get('indexedAt'))
                    post_time = parser.parse(created_at).replace(tzinfo=timezone.utc)
                    time_jst = post_time.astimezone(JST)
                    time_str = time_jst.strftime('%H:%M')
                    author = item['post']['author'].get('displayName') or item['post']['author']['handle']
                    content = item['post']['record'].get('text', '')
                    return {
                        'entry': f"- {time_str} â­ï¸{author} {content} #via_bluesky_fav",
                        'date': time_jst.date(),
                        'time': time_jst
                    }
        
        
        class DailyNoteManager:
            """æ—¥è¨˜ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†"""
            def __init__(self):
                self.entries_by_date = {}
                
            def add_entries(self, entries):
                """ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’æ—¥ä»˜åˆ¥ã«è¿½åŠ """
                for entry in entries:
                    date_str = entry['date'].strftime('%Y-%m-%d')
                    if date_str not in self.entries_by_date:
                        self.entries_by_date[date_str] = []
                    self.entries_by_date[date_str].append(entry)
                    
            def save_all(self):
                """ã™ã¹ã¦ã®æ—¥è¨˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜"""
                for date_str, entries in self.entries_by_date.items():
                    self.save_daily_note(date_str, entries)
                    time.sleep(0.5)  # ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã®é–“éš”
                    
            def save_daily_note(self, date_str, new_entries):
                """æ—¥è¨˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°"""
                filename = f"Thino/{date_str}.md"
                
                # æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
                existing_entries = []
                if os.path.exists(filename):
                    try:
                        with open(filename, 'r', encoding='utf-8') as f:
                            content = f.read().strip()
                            if content:
                                lines = content.split('\n')
                                # æ—¥ä»˜ãƒ˜ãƒƒãƒ€ãƒ¼ä»¥å¤–ã®è¡Œã‚’æŠ½å‡º
                                for line in lines:
                                    if line.startswith('- '):
                                        existing_entries.append(line)
                    except Exception as e:
                        logging.warning(f"æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
                
                # é‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨ã®ã‚»ãƒƒãƒˆ
                existing_set = set(existing_entries)
                
                # æ–°è¦ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’è¿½åŠ ï¼ˆé‡è¤‡æ’é™¤ï¼‰
                all_entries = existing_entries.copy()
                added_count = 0
                for entry in new_entries:
                    if entry['entry'] not in existing_set:
                        all_entries.append(entry['entry'])
                        existing_set.add(entry['entry'])
                        added_count += 1
                
                if added_count == 0:
                    logging.info(f"å¤‰æ›´ãªã—: {filename}")
                    return
                
                # æ™‚åˆ»ã§ã‚½ãƒ¼ãƒˆ
                def extract_time(entry_line):
                    match = re.match(r'- (\d{2}:\d{2})', entry_line)
                    return match.group(1) if match else '00:00'
                
                all_entries.sort(key=extract_time)
                
                # ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
                try:
                    date_obj = datetime.strptime(date_str, '%Y-%m-%d')
                    header = f"# {date_obj.strftime('%Yå¹´%mæœˆ%dæ—¥')}\n\n"
                    
                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(header)
                        f.write('\n'.join(all_entries))
                        if all_entries:
                            f.write('\n')
                    
                    logging.info(f"âœ… æ›´æ–°å®Œäº†: {filename} (æ–°è¦ {added_count}ä»¶, åˆè¨ˆ {len(all_entries)}ä»¶)")
                    
                except Exception as e:
                    logging.error(f"ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿ã‚¨ãƒ©ãƒ¼ ({filename}): {e}")
        
        
        def main():
            """ãƒ¡ã‚¤ãƒ³å‡¦ç†"""
            execution_start_time = datetime.now(JST)
            logging.info("ğŸš€ çµ±åˆã‚½ãƒ¼ã‚·ãƒ£ãƒ«ãƒ¡ãƒ‡ã‚£ã‚¢åŒæœŸã‚’é–‹å§‹ã—ã¾ã™...")
            logging.info(f"â° å®Ÿè¡Œé–‹å§‹æ™‚åˆ»: {execution_start_time.strftime('%Y-%m-%d %H:%M:%S')} JST")
            
            # çŠ¶æ…‹ç®¡ç†ã®åˆæœŸåŒ–
            sync_state = UnifiedSyncState()
            if FORCE_FULL_SYNC:
                logging.info("ğŸ”„ å¼·åˆ¶ãƒ•ãƒ«åŒæœŸãŒæŒ‡å®šã•ã‚Œã¾ã—ãŸ")
                sync_state.state['is_first_run'] = True
            
            # æ—¥è¨˜ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†ã®åˆæœŸåŒ–
            note_manager = DailyNoteManager()
            
            # çµ±è¨ˆæƒ…å ±
            stats = {
                'mastodon_posts': 0,
                'mastodon_favs': 0,
                'mastodon_bookmarks': 0,
                'bluesky_activities': 0,
                'bluesky_likes': 0,
                'total_files': 0
            }
            
            # 1. MastodonåŒæœŸ
            if MASTODON_ACCESS_TOKEN and MASTODON_INSTANCE_URL:
                logging.info("\n=== MastodonåŒæœŸ ===")
                try:
                    mastodon = MastodonSync(MASTODON_INSTANCE_URL, MASTODON_ACCESS_TOKEN, sync_state)
                    
                    # ã‚¢ã‚«ã‚¦ãƒ³ãƒˆIDå–å¾—
                    account_id = mastodon.get_account_id()
                    if account_id:
                        # æŠ•ç¨¿å–å¾—
                        posts = mastodon.fetch_posts(account_id)
                        if posts:
                            entries = []
                            for post in posts:
                                entry = mastodon.format_entry(post, 'post')
                                entries.append(entry)
                            note_manager.add_entries(entries)
                            stats['mastodon_posts'] = len(posts)
                            
                            # æœ€æ–°ã®æŠ•ç¨¿IDã‚’ä¿å­˜
                            if posts:
                                sync_state.state['mastodon']['last_post_id'] = posts[0]['id']
                        
                        # ãŠæ°—ã«å…¥ã‚Šå–å¾—
                        favourites = mastodon.fetch_favourites()
                        if favourites:
                            entries = []
                            for fav in favourites:
                                entry = mastodon.format_entry(fav, 'favourite')
                                entries.append(entry)
                            note_manager.add_entries(entries)
                            stats['mastodon_favs'] = len(favourites)
                        
                        # ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯å–å¾—
                        bookmarks = mastodon.fetch_bookmarks()
                        if bookmarks:
                            entries = []
                            for bookmark in bookmarks:
                                entry = mastodon.format_entry(bookmark, 'bookmark')
                                entries.append(entry)
                            note_manager.add_entries(entries)
                            stats['mastodon_bookmarks'] = len(bookmarks)
                        
                        # å®Ÿè¡Œæ™‚åˆ»ã‚’ä¿å­˜
                        sync_state.state['mastodon']['last_execution_time'] = execution_start_time.isoformat()
                        
                except Exception as e:
                    logging.error(f"MastodonåŒæœŸã‚¨ãƒ©ãƒ¼: {e}")
                    logging.info("MastodonåŒæœŸã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ç¶šè¡Œã—ã¾ã™")
            else:
                logging.info("Mastodonè¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ - ã‚¹ã‚­ãƒƒãƒ—")
            
            # 2. BlueskyåŒæœŸ
            if BLUESKY_HANDLE and BLUESKY_PASSWORD:
                logging.info("\n=== BlueskyåŒæœŸ ===")
                try:
                    bluesky = BlueskySync(BLUESKY_HANDLE, BLUESKY_PASSWORD, sync_state)
                    
                    if bluesky.login():
                        # ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£å–å¾—
                        activities = bluesky.fetch_activities()
                        if activities:
                            entries = []
                            for activity in activities:
                                entry = bluesky.format_entry(activity, 'activity')
                                entries.append(entry)
                            note_manager.add_entries(entries)
                            stats['bluesky_activities'] = len(activities)
                        
                        # ãƒ©ã‚¤ã‚¯å–å¾—
                        likes = bluesky.fetch_likes()
                        if likes:
                            entries = []
                            for like in likes:
                                entry = bluesky.format_entry(like, 'like')
                                entries.append(entry)
                            note_manager.add_entries(entries)
                            stats['bluesky_likes'] = len(likes)
                        
                        # å®Ÿè¡Œæ™‚åˆ»ã‚’ä¿å­˜
                        sync_state.state['bluesky']['last_execution_time'] = execution_start_time.isoformat()
                        
                except Exception as e:
                    logging.error(f"BlueskyåŒæœŸã‚¨ãƒ©ãƒ¼: {e}")
                    logging.info("BlueskyåŒæœŸã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ç¶šè¡Œã—ã¾ã™")
            else:
                logging.info("Blueskyè¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ - ã‚¹ã‚­ãƒƒãƒ—")
            
            # 3. æ—¥è¨˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜
            logging.info("\n=== ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ ===")
            note_manager.save_all()
            stats['total_files'] = len(note_manager.entries_by_date)
            
            # 4. çŠ¶æ…‹ã‚’ä¿å­˜
            sync_state.state['is_first_run'] = False
            sync_state.save()
            
            # 5. å®Œäº†å ±å‘Š
            logging.info("\nğŸ‰ çµ±åˆåŒæœŸå®Œäº†ï¼")
            logging.info("=" * 50)
            logging.info("ğŸ“Š å‡¦ç†çµæœ:")
            logging.info(f"  Mastodon:")
            logging.info(f"    - æŠ•ç¨¿: {stats['mastodon_posts']}ä»¶")
            logging.info(f"    - ãŠæ°—ã«å…¥ã‚Š: {stats['mastodon_favs']}ä»¶")
            logging.info(f"    - ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯: {stats['mastodon_bookmarks']}ä»¶")
            logging.info(f"  Bluesky:")
            logging.info(f"    - ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£: {stats['bluesky_activities']}ä»¶")
            logging.info(f"    - ãƒ©ã‚¤ã‚¯: {stats['bluesky_likes']}ä»¶")
            logging.info(f"  ğŸ“ æ›´æ–°ãƒ•ã‚¡ã‚¤ãƒ«æ•°: {stats['total_files']}å€‹")
            logging.info(f"â° å®Ÿè¡Œæ™‚é–“: {(datetime.now(JST) - execution_start_time).total_seconds():.1f}ç§’")
            logging.info(f"ğŸ“ çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«: {UNIFIED_STATE_FILE}")
            
        
        if __name__ == "__main__":
            main()
        EOF
        
    - name: Commit and push changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add Thino/
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "ğŸ¤– çµ±åˆã‚½ãƒ¼ã‚·ãƒ£ãƒ«ãƒ¡ãƒ‡ã‚£ã‚¢åŒæœŸ: $(TZ='Asia/Tokyo' date +'%Yå¹´%mæœˆ%dæ—¥ %H:%M JST')"
          git push
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
